// Copyright (c) 2020 Tailscale Inc & AUTHORS All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package depaware is the guts of the depaware program.
//
// It's in its own package so others can empty-import depend on it and
// pin a specific version of depaware in their go.mod files.
package depaware

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/pkg/diff"
	"github.com/pkg/diff/write"
	"golang.org/x/tools/imports"
)

// the go list -json format (parts we care about)
type jsonOutput struct {
	Dir        string
	ImportPath string
	Imports    []string
	Deps       []string
}

var (
	check  = flag.Bool("check", false, "if true, check whether dependencies match the depaware.txt file")
	update = flag.Bool("update", false, "if true, update the depaware.txt file")
	osList = flag.String("goos", "linux,darwin,windows", "comma-separated list of GOOS values")
)

func Main() {
	flag.Parse()
	if flag.NArg() != 1 {
		fmt.Fprintf(os.Stderr, "Usage: depaware [flags] <package-name>\n")
		os.Exit(1)
	}
	pkg := flag.Arg(0)

	if *check && *update {
		log.Fatalf("-check and -update can't be used together")
	}

	geese := strings.Split(*osList, ",")
	var d deps
	var dir string
	for _, goos := range geese {
		cmd := exec.Command("go", "list", "-json", pkg)
		cmd.Env = append(os.Environ(), "GOARCH=amd64", "GOOS="+goos, "CGO_ENABLED=1")
		cmd.Stderr = os.Stderr
		out, err := cmd.Output()
		if err != nil {
			log.Fatal(err)
		}

		var meta jsonOutput
		if err := json.Unmarshal(out, &meta); err != nil {
			log.Fatalf("bogus output from go list -json: %v", err)
		}
		if dir == "" {
			dir = meta.Dir
		}
		if strings.HasPrefix(pkg, ".") {
			pkg = meta.ImportPath
		}

		for _, target := range meta.Imports {
			d.AddEdge(meta.ImportPath, target)
		}
		for _, depPkg := range meta.Deps {
			d.AddDep(depPkg, goos)
		}

		cmd = exec.Command("go", "list", "-json")
		cmd.Env = append(os.Environ(), "GOARCH=amd64", "GOOS="+goos, "CGO_ENABLED=1")
		cmd.Args = append(cmd.Args, meta.Deps...)
		cmd.Stderr = os.Stderr
		out, err = cmd.Output()
		if err != nil {
			log.Fatalf("for GOOS=%v: %v", goos, err)
		}
		jd := json.NewDecoder(bytes.NewReader(out))
		for {
			var meta jsonOutput
			err := jd.Decode(&meta)
			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatal(err)
			}
			for _, target := range meta.Imports {
				d.AddEdge(meta.ImportPath, target)
			}
		}
	}

	sort.Slice(d.Deps, func(i, j int) bool {
		d1, d2 := d.Deps[i], d.Deps[j]
		if p1, p2 := strings.Contains(d1, "."), strings.Contains(d2, "."); p1 != p2 {
			return p1
		}
		if x1, x2 := strings.Contains(d1, "golang.org/x/"), strings.Contains(d2, "golang.org/x/"); x1 != x2 {
			return x2
		}
		return d1 < d2
	})

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "%s dependencies: (generated by github.com/tailscale/depaware)\n\n", pkg)
	var osBuf bytes.Buffer

	for _, pkg := range d.Deps {
		icon := "  "
		if d.UsesUnsafe[pkg] && !isGoPackage(pkg) {
			icon = "ðŸ’£"
		}
		osBuf.Reset()
		for _, goos := range geese {
			if d.DepOnOS[pkg][goos] {
				osBuf.WriteRune(unicode.ToUpper(rune(goos[0])))
			}
		}
		if osBuf.Len() == len(geese) {
			osBuf.Reset()
		}
		fmt.Fprintf(&buf, " %3s %s %-60s %s\n", osBuf.Bytes(), icon, pkg, d.Why(pkg))
	}

	daFile := filepath.Join(dir, "depaware.txt")
	if *check {
		was, err := ioutil.ReadFile(daFile)
		if err != nil {
			log.Fatal(err)
		}
		if bytes.Equal(was, buf.Bytes()) {
			// Success. No changes.
			return
		}
		var opts []write.Option
		if os.Getenv("TERM") != "dumb" {
			opts = append(opts, write.TerminalColor())
		}
		fmt.Fprintf(os.Stderr, "The list of dependencies in %s is out of date.\n\n", daFile)
		err = diff.Text("before", "after", was, buf.Bytes(), os.Stderr, opts...)
		if err != nil {
			log.Fatal(err)
		}
		os.Exit(1)
	}

	if *update {
		if err := ioutil.WriteFile(daFile, buf.Bytes(), 0644); err != nil {
			log.Fatal(err)
		}
		return
	}

	os.Stdout.Write(buf.Bytes())
}

type deps struct {
	Deps    []string
	DepOnOS map[string]map[string]bool // pkg -> goos -> true

	DepTo      map[string][]string // pkg in key is imported by packages in value
	UsesUnsafe map[string]bool
}

func (d *deps) Why(pkg string) string {
	from := d.DepTo[pkg]
	if len(from) == 0 {
		return ""
	}
	sort.Strings(from)
	plus := ""
	if len(from) > 1 {
		plus = "+"
	}
	return "from " + from[0] + plus
}

func (d *deps) AddEdge(from, to string) {
	from = imports.VendorlessPath(from)
	to = imports.VendorlessPath(to)
	if d.DepTo == nil {
		d.DepTo = make(map[string][]string)
		d.UsesUnsafe = make(map[string]bool)
	}
	if !stringsContains(d.DepTo[to], from) {
		d.DepTo[to] = append(d.DepTo[to], from)
	}
	if to == "unsafe" || to == "C" {
		d.UsesUnsafe[from] = true
	}
}

func (d *deps) AddDep(pkg, goos string) {
	pkg = imports.VendorlessPath(pkg)
	if isBoringPackage(pkg) {
		return
	}
	if !stringsContains(d.Deps, pkg) {
		d.Deps = append(d.Deps, pkg)
	}
	if d.DepOnOS == nil {
		d.DepOnOS = map[string]map[string]bool{}
	}
	if d.DepOnOS[pkg] == nil {
		d.DepOnOS[pkg] = map[string]bool{}
	}
	d.DepOnOS[pkg][goos] = true
}

func stringsContains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}

func isBoringPackage(pkg string) bool {
	return strings.HasPrefix(pkg, "internal/") ||
		strings.HasPrefix(pkg, "runtime/internal/") ||
		pkg == "runtime" || pkg == "runtime/cgo" || pkg == "unsafe" ||
		(strings.Contains(pkg, "/internal/") && isGoPackage(pkg))
}

func isGoPackage(pkg string) bool {
	return !strings.Contains(pkg, ".") ||
		strings.Contains(pkg, "golang.org/x")
}
